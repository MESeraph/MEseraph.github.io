文|Seraph   
题目：Leetcode 107 

### 1 问题
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
   ```
返回其自底向上的层次遍历为：
```
[
  [15,7],
  [9,20],
  [3]
]
```


### 2 解题
#### 初解：
***思路：*** 一开始想，从底到顶，很难确定当前在哪一层，从而就很难分层统计数。后面一想，处理应该还是从顶到底，借助队列分层遍历，然后倒置层数据就行了。
但还有一个需要处理的细节就是，怎么确认该跳层了。
以下思路是利用两个循环，内部循环进入时，通过判断当前队列有多少个数据进行处理，必须处理完，才能跳出内部循环，因为这些数据肯定在同在一层。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> result;
        deque<TreeNode *> deTemp;
        if(root != nullptr)
        {
            deTemp.push_back(root);
        }
       
        while(!deTemp.empty())
        {
            vector<int> vcTemp;
            int iSize = deTemp.size();
            for(int i=0; i<iSize; i++)
            {
                TreeNode *tNode = deTemp.front();
                deTemp.pop_front();
                if(tNode->left != nullptr)
                {
                    deTemp.push_back(tNode->left);
                }
                if(tNode->right != nullptr)
                {
                    deTemp.push_back(tNode->right);
                }
                vcTemp.push_back(tNode->val);
            }
            result.push_back(vcTemp);
        }
        
        reverse(result.begin(), result.end());
        return result;
    }
};
```
   
### 终解：
再者，利用递归可以直接导致统计层，如下：
```cpp
void levelOrderBottom(queue<TreeNode *> que, vector<vector<int>> &ans)
{
	if (que.empty()) return;
	queue<TreeNode *> queNext;
	vector<int> vec;
	while (!que.empty())
	{
		TreeNode *pNode = que.front();
		que.pop();
		vec.push_back(pNode->val);
		if (pNode->left != nullptr) queNext.push(pNode->left);	
		if (pNode->right != nullptr) queNext.push(pNode->right);
	}
	levelOrderBottom(queNext, ans);
	ans.push_back(vec);
}

vector<vector<int>> levelOrderBottom(TreeNode* root) 
{
	vector<vector<int>> ans;
	queue<TreeNode *> q;
	if (root != nullptr) q.push(root);
	levelOrderBottom(q, ans);
	return ans;
}
```

### 3 积累知识点
1. `reverse(begin(), end())`反转容器里的数据。
